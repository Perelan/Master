\chapter{Source Code}
The source code for the various applications in context of this thesis can be found at following Github repository: \textit{https://github.com/perelan/master}

\section{File and Folder Structure}
\begin{description}
    \item[Nidra] encompasses the implementation performed in the Chapther 5. The application follows the MVVM architecture pattern, thus the naming scheme of the folders advertently follows the seperation of the components in the architecture pattern. The folder structure for the application code is seperated into:
    \begin{itemize}
        \item \textbf{Dispatcher}: contains the code for communication with the DataStreamDispatchingModule including the service for data acquisition, and the code for reconnectivity with the sensor sources on sensor disconnect or human disruption.
        \item \textbf{Model}: contains the model for data entities, structure for the sensor data and Flow payload data, and the interface for establishing connection with SQLite (with Android Room).
        \item \textbf{Utils}: comprise of miscellaneous code ranging from functionality to extract Flow payload to logic behind the export functionality. 
        \item \textbf{View}: include the activities (discussed in Chapther 5) with seperation of various views (e.g., feed, module and recording). 
        \item \textbf{ViewModel}: exposes the operations that can be performed on the data entities. 
    \end{itemize}

    \item[DataStreamDispatchingModule] encompasses the implemention made by Bugasjki. However, the application was extended during the course of this thesis and can be reflected into the following files: 
    \begin{itemize}
        \item \textbf{SensorDiscovery} listens for broadcasts sent by the sensor wrappers on start. The data passed alongside the broadcasts is extracted of name and packagename, and stored in a \verb|SharedPreferences| if it does not exists. 
        \item \textbf{Sensor} is the sensor objective that is stored into the \verb|SharedPreferences| mentioned above, with the name and the packagename of the sensor wrapper. 
    \end{itemize}

    \item[Flow] encompasses the driver for creating a sensor wrapper made by Gjøby. The sensor wrapper adds the support for Flow sensor kit, and the extention made to enable the sensor wrapper (besides the components introduced by Gjøby) are the following:
    \begin{itemize}
        \item \textbf{Bluetooth} include the code for connecting with the Flow sensor kit with Bluetooth LE. Most of the logic is in the file \verb|BluetoothHandler|, and the code is inspired by the application \textit{RawDataMonitor} sent to us from Sagar Sen at SweetZpot Inc. 
        \item \textbf{View} contains the activity for listing the available sensors on the screen. 
    \end{itemize}

    \item[TestModule] encompasses a boilerplate code for creating a new module (further discussed in Appendix C).
    \item[Thesis] encompasses the LaTeX for this thesis, including figures and UiO master's thesis format.
    \item[Graph] encompasses the data acquired from the various mobile devices during the two concert dates including a Python script for plotting it in a time-series graph.

\end{description}

\chapter{Expatiate on Concert Experiement}

\section{Concert Day 1: Time-Series Graph}
This Section illustrates the samples collected during the concert the concert on third April of 2019, which lasted 
for one hour. There are six indiviual records for this day: 

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_a.pdf}
    \caption{Concert Day 1: Device A}
    \label{fig:concert_day1_a}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_b.pdf}
    \caption{Concert Day 1: Device B}
    \label{fig:concert_day1_b}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_c.pdf}
    \caption{Concert Day 1: Device C}
    \label{fig:concert_day1_c}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_d.pdf}
    \caption{Concert Day 1: Device D}
    \label{fig:concert_day1_d}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_e.pdf}
    \caption{Concert Day 1: Device E}
    \label{fig:concert_day1_e}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_1_f.pdf}
    \caption{Concert Day 1: Device F}
    \label{fig:concert_day1_f}
\end{figure}

\section{Concert Day 2: Time-Series Graph}


\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_a.pdf}
    \caption{Concert Day 2: Device A}
    \label{fig:concert_day2_a}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_b.pdf}
    \caption{Concert Day 2: Device B}
    \label{fig:concert_day2_b}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_c.pdf}
    \caption{Concert Day 2: Device C}
    \label{fig:concert_day2_c}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_d.pdf}
    \caption{Concert Day 2: Device D}
    \label{fig:concert_day2_d}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_e.pdf}
    \caption{Concert Day 2: Device E}
    \label{fig:concert_day2_e}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/record_2_f.pdf}
    \caption{Concert Day 2: Device F}
    \label{fig:concert_day2_f}
\end{figure}

\newpage
\section{Python Code for Plotting}
The following Listing presents the code used for plotting the data from the concert into a time-series graph. 

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
import json
import matplotlib.pyplot as plt
from matplotlib.dates import DateFormatter
from datetime import datetime
from statistics import mean
import sys 
import seaborn

plt.style.use('seaborn')

sample_count = 0

def get_data(sample):
    data = sample[2].split("=")[1].split(",")
    avg = mean([int(i) for i in data])
    return avg

def get_date(sample):
    global sample_count

    if sample > '20:10:00' and sample < '21:00:00':
        sample_count += 1

    return datetime.strptime(sample, '%H:%M:%S')

def parse(data, name):
    global sample_count

    date = [get_date(i['implicitTS'].split(" ")[-1]) for i in data[0]['samples']]
    data = [get_data(i['sample'].split(", ")) for i in data[0]['samples']]

    fig, ax = plt.subplots()
    plt.plot(date, data)

    ax.xaxis.set_major_formatter(DateFormatter('%H:%M:%S'))
    ax.xaxis_date()
    ax.xaxis.set_tick_params(rotation=45)

    ax.set_xlabel("Time")
    ax.set_ylabel("Respiration value")
    ax.set_title(name)

    plt.show()
    
    print(sample_count)

def read(filename="record_1_B.json"):
    with open(filename) as f:
        json_data = json.load(f)

        parse(json_data, filename)

if __name__ == "__main__":
    if len(sys.argv) == 2:
        read(sys.argv[1])
    else:
        read()
\end{lstlisting}


\chapter{Module Template}
To expedite the creation of a new module a template with pre-code is provided. The pre-code contains a blank Android project with the latest Gradle version 3.4.0 and support for Android 9 (API level 28). In the subsequent Sections, the instructions of duplicating the template is presented. 



\section{Application Setup}

\subsection{Download the Application}
Start by locating the \textit{ModuleTemplate} application in the Github repository for this thesis. Download the application folder, rename it with desired name, and move it to the \verb|Android Studio| project folder. Listing X presents the commands to accomidate for the actions. Next, import the project in Android Studio by pressing \verb|File --> Open --> (Name of Application)|

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
git clone https://github.com/Perelan/Master.git
cd Master
mv ModuleTemplate <Path to Android Studio Project>/<Desired Name>
\end{lstlisting}

\subsection{Change the Name of the Application}
Change the name of the application such that the user can locate the application in the app drawer, also the name is used as the module-name when listed in Nidra. The name change is performed by locating the \verb|app_name| inside of \verb|strings.xml| which is to be found in \verb|res/value|, see Listing below. 

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
<resources>
    <string name="app_name">ModuleTemplate</string> <-- Change this!
</resources>
\end{lstlisting}

\subsection{Rename the Package of the Application}
Change the package name of the application by following Listing X. It is incentivized to keep the prefix of \textit{com.cesar.X} to group future modules by the package name. 

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
Right Click => Refactor => Rename => Rename Package => *new package name* => Refactor
\end{lstlisting}

\subsection{Change the Application ID}
Finally, change the application ID respectivly to the package name defined above---the ID is used to seperate installed applications from each other. The application ID is located in the \verb|build.gradle| file inside of the \verb|app| folder of the project. See Listing X.

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
android {
    defaultConfig {
        applicationId "com.cesar.moduletemplate"
    }
}
\end{lstlisting}

\section{Application Execution}


\subsection{Add the Module to Nidra}
In order to retrieve the records data, the module-application has to be added to Nidra. Therefore, launch the Nidra application on the device and navigate to the modules screen. Press the \textit{Add new Module} button, find the module by name in the list and click to add. 

\subsection{Retrieve the Data}
The data is sent as a JSON string to the module when it is launched within Nidra. The pre-code is seperated into following files and folder:

\begin{description}
    \item[MainActivity] On creation of the module-application, the bundle of data that is sent as an Intent is passed to the \verb|Extract| method in \verb|DataExtraction|.
    \item[DataExtraction] The \verb|Extract| method retrieves the JSON string from the bundle with the key \textit{data}, and returns a unmarshalls of the data into a \verb|PayloadFormat| object
    \item[Payload/PayloadFormat] Is the object in which one of the record with corresponding samples of the data is marshalled. It encompasses a single record that contains metadata and user information, also a list of samples. 
    \item[Payload/Record] contains the record metadata (see Section X)
    \item[Payload/Sample] contains a single sample (see Section X)
    \item[Payload/User] contains the state of the user information at the given time of recording (see Section X).
\end{description}

As part of the discussion of the module design, the records is sent to the module-application only when it is launched within Nidra. This might become cumbersome in the long run, therefore, it is highly incentivized to temporarly cache the data under development. 


\chapter{Flow Sensor Wrapper}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{images/flow_app.pdf}
    \caption{Flow Sensor Wrapper---A}
    \label{fig:flowapp}
\end{figure}