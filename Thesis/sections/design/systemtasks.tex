\subsubsection{System Tasks}

\textbf{Recording}

\noindent A \textit{recording} is a process of collecting and storing physiological signals from sensors over an extended period (i.e., overnight). To enable a recording, we need to establish connections to available sensors, collecting samples from the sensors and storing the samples on the device. A \textit{sensor} is a device that transforms analog signals from the real world into digital signals.  physiological signals over a medium (e.g., Bluetooth). The application and the sensors are separate components, and the communication between these components occurs over an application programming interface (API) [write more?]. A \textit{sample} is a single sensor reading containing data and metadata, such as time and physiological data.  

\noindent \textbf{Sharing}

\noindent Sharing is a mechanism to export and import recordings across applications. \textit{Exporting} consists of bundling records with correlated samples into a format that can be transmitted. The format can be structured varyingly, however, we will discuss as few distinguishable formats that are applicable:

\begin{itemize}
    \item JSON - is a file format used to transmit data objects consisting of attribute-value pairs and array data types [wikipedia, JSON, 9.mai]. JSON has a simple syntax, which results in a compact file and efficient transmission. However, it only supports a few data types.
    \item XML - is a markup language that encodes arbitrary data structures into a format that is human-readable and machine-readable [wikipedia, XML, 9.mai]. XML provides a generalized markup that has support for numerous data types, structure validation, and extensions. However, the structure of XML results in a larger file[?]
    \item Constructing a file format solely for transmitting records and samples - by introducing a file format that is restrictive to the purpose of records and sample, we can minimize the transmitting file size. However, this might result in unreadable text, the overhead of parsing and transforming, and incompatibilities amongst devices. 
\end{itemize}
While these format structures are applicable for transmitting data, choosing a format that is compact, human-readable, and universal is essential. In order to design this application, we will be using the JSON format for transmission of the data, as it meets the specified criteria. 

Once a preferred format for the recording is selected and stored in an exportable file, transferring the file to another device is made possible. One way is by transferring the files with the desired recipient through a server/middleware[?]; this makes it easier for users to share files amongst each other. Another way of transferring a file from one device to another is by sharing it through applicable mediums (e.g., email). The former requires additional functionality, such as registering users to distinguish recipients and additional security measurements for securing personal information. Therefore, a more preferable and secure solution would be to use the former solution. 

\textit{Importing} is accomplishable by locating the file, parsing the file, and storing the recordings in storage. A naive solution for the location of a file is by assuming that the file is located in on the same location amongst all devices, thus trying locating the file on a static location. Therefore, providing an interface to the users to deliberately locate the desired file in the file hierarchy of its device is practical. Android provides an interface for such a solution [?]. With the exact path of the file, we can read the bitstream of the file and parse the data according to the chosen format, and store the content of the file on the device.

\noindent \textbf{Modules}

\noindent Modules are independent applications that can be launched in the application to provide extended functionality and data enrichment. A module does not necessarily interact with the application itself. However, it utilizes the data (e.g., recordings) provided from the application. For instance, a module could be using the recordings to feed a machine learning algorithm to predict obstructive sleep apnea. Installing a module can be done by locating the module-application on the device, and can then be launched from the application. However, due to limitations in Android, the module-application cannot be executed within the application. Therefore, modules are run as independent application alongside the application.

The data exchange between a module and the application is possible on two various methods. One way is by selecting one or all of the recordings and bundling the data and sending it on launch. Another way is by establishing a direct communication link for pull-based requests, where the records are sent based on the requests of the module. The latter solution provides less overhead on data transfer; however, requires extended functionality to made possible. The former solution sends all of the selected data to the module on the launch, and there are no methods of communication with the application once a module is running. Essentially, the recordings do not change once it is on the device. Thus the former solution is feasible. 


\noindent \textbf{Storage}

\noindent Storage is the objective of achieving persistent data; data that is available after application termination.  To enable storage, we can use a database for a collection of related data that is easily accessed, managed, and updated [Database Systems, p. 52]. Three distinguishable databases structures are:
\begin{itemize}
    \item Flat file - encode a database model (e.g., table) with a collection of records without any structured relationship, in a plain text or binary file [system nosql analysis]. 
    \item Relational Database - consists of relations between data stored in tables; supporting complex queries, database transactions, and   Additionally, ensuring ACID (atomicity, consistency, isolation, and durability) properties for reliable database transactions. 
    \item Non-Relational Database - While these database structures are applicable to achieve persistent data storage, using relational database is suitable for our 
\end{itemize}



The placement of storage can be located externally on a server or internally on the device. External storage provides larger storage capacity, in addition to faster computing power. Facilitating external storage can be accomplished with maintaining a server, or utilizing a cloud service (e.g., Google Cloud) for the purpose. Internal storage provides limited storage capacity and computing power, however, the storage and retrieval data is efficient.  While both are applicable, the internal storage is more than efficient for the application.

Two distinguishable methods of structuring a storage 
There are several methods of structuring the storage on, and two distinguishable methods are a flat file or a database management system (hereafter, DBMS). File storage is a bare minimum structure of storing and retrieving data. The data is stored, with a format (e.g., JSON), in a raw file. Retrieving data occurs by reading the whole file into memory, parsing the data and then operating on the data.