\subsection{Data Formats}

The data format is a part of the process of serialization, which enables data storage in a file, transmittal over the Internet, and reconstruction in a different environment. Serialization is the process of converting the state of an object into a stream of bytes, which later can be deserialized by rebuilding the stream of bytes to the original object. There are several data serialization formats; however, JavaScript Object Notation (JSON) and eXtensible Markup Language (XML) are the two most common data serialization formats. In this Section, we will discuss these formats. In the end, we will compare them and choose the format that meets the criteria of being compact, human-readable, and universal. 

\subsubsection{JSON}
JSON or JavaScript Object Notation is a light-weight and human-readable format that is commonly used for interchanging data on the web. The format is a text-based solution where the data structure is built on two structures: a collection of name-value pairs (known as objects) and ordered list of values (known as arrays). The JSON format is language-independent and the data structure universally recognized \cite{jsonorg, jsonvxml}. However, it is limited to a few predefined data types (i.e., string, number, boolean, object, array, and null), and extending the data type has to be done with the preliminary types. 

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
{
    "user": {
        "firstname": "Ola"
        "lastname": "Nordmann"
    }
}
\end{lstlisting}

\subsubsection{XML}
XML or eXtensible Markup Language is a simple and flexible format derived from Standard Generalized Markup Language (SGML), developed by the XML Working Group under the World Wide Web Consortium (W3C). An XML document consists of markups called tags, which are containers that describe and organize the enclosed data. The tag starts with \verb|<| and ends with \verb|>|; the content is placed between an opening tag and a closing tag (see listing). \cite{w3xml, jsonvxml} XML provides mechanisms to define custom data types, using existing data types as a starting point, making it extensible for future data. 

\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
<user>
    <firstname>Ola</firstname>
    <lastname>Nordmann</lastname>
</user>
\end{lstlisting}

\subsubsection{Comparing}
We will compare JSON and XML features and performance with the study conducted by Saurabh and Dâ€™Souza \cite{jsonvxml}. There are apparent differences in the two data formats which affect the overall readability, extensibility, bandwidth performance, and ease of mapping. XML documents are easy to read, while JSON is obscure due to the parenthesis delimiters. XML allows for extended data types, while JSON is limited to a few data types. XML takes more bandwidth due to the metadata overhead, while JSON data is compact and use less amount of bandwidth.

Moreover, a few benchmarks were conducted to measure memory footprint and parsing runtime when serializing and deserializing JSON and XML data. From the conclusion,  in terms of memory footprint and parsing runtime, JSON performances better than XML but at the cost of readability and flexibility. While these format structures are applicable for transmitting data, choosing a format that is compact, human-readable, and a standard format that is extensible and scalable for future data is essential. In our design, we will be using the JSON format for transmission of the data.

\subsection{Data Tables}
Data tables are a collection of structured and related data in a tabular format in a database. Subsection about Storage introduces four data tables in the application.  In Figure \ref{fig:dataentries}, the relation between these tables are shown. Record and sample are separated in order to reduce data redundancy and improve data integrity; however, samples have a reference to a record so they can be associated with each other. A user can have many records; however, a record can only have one user. The module table has no relation to the other tables in the database. This Subsection will demonstrate the properties of each table in Nidra, with an illustration of a record inside each table.

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{images/DataEntries.png}
    \caption{Modules}
    \label{fig:dataentries}
\end{figure}

\subsubsection{Record}

A record is a table in the database that stores metadata related to the recording session. In Table 4.1, an illustration of the structure of a record is shown, with an entry of dummy data. In Nidra, the fields in the table for a record describe the data that is stored, which is separated into:
\begin{itemize}
	\item \verb|ID|: Unique identification of a record, also a primary key for the entry.
	\item \verb|Name|: A name of the record to easily recognize the recording.
	\item \verb|Description|: A summary over the recording session, used to describe briefly how the recording session felt (e.g., any abnormalities during the sleep).
	\item \verb|MonitorTime|: The recording session duration in milliseconds.
	\item \verb|Rating|: Giving a rating on how the sleeping session felt, in a range between 0-5. 
	\item \verb|User|: Identification of the user, also a foreign key to the user table.
	\item \verb|CreatedAt|: Date of creation of the recording in milliseconds (since January 1, 1970, 00:00:00 GMT).
	\item \verb|UpdatedAt|: Date of update of the recording in milliseconds (since January 1, 1970, 00:00:00 GMT).
\end{itemize}


\begin{table}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{ |c|c|c|c|c|c|c|c| } 
\hline
\textbf{id} & \textbf{name} & \textbf{description} & \textbf{monitorTime} & \textbf{rating} & \textbf{user} & \textbf{createdAt} & \textbf{updatedAt} \\
\hline
1 & Record \#1 & & 5963088 & 2.5 & 1 & 1554406256000 & 1554406256000  \\ 
\hline
\end{tabular}}
\caption{Example entry in record table}
\end{center}
\end{table}


\subsubsection{Sample}
A sample is a single sensor reading containing data and metadata related to the recording session. Samples are stored separated from a record; however, they are linked with a field in the table.  In Table 4.1, an illustration of the structure of a sample is shown, with an entry of dummy data. In Nidra, the fields in the table for a sample describe the data that is stored accordingly to the data provided by Flow SweetZpot (ref), which are separated into:
\begin{itemize}
	\item \verb|ID|: Unique identification of a sample, also a primary key for the entry.
	\item \verb|RecordID|: An identification to its correlated record, also a foreign key. 
	\item \verb|ExplicitTS|: Timestamp of sample arrival based on the time in the sensor. 
	\item \verb|ImplicitTS|: Timestamp of sample arrival based on the time on the device. 
	\item \verb|Sample|: Sensor reading contains metadata and data according to Flow Sweetzpot. The sensor aggregates seven samples in a single sensor reading. 
\end{itemize}

\begin{table}
\begin{center}
\scalebox{0.65}{
\begin{tabular}{ |c|c|c|c|c| } 
\hline
\textbf{id} & \textbf{recordId} & \textbf{explicitTS} & \textbf{implicitTS} & \textbf{sample} \\
\hline
1 & 1 & & 5963088 & Time=0ms, deltaT=100, data=1906,1891,1884,1881,1876,1718,1690 \\ 
\hline
\end{tabular}}
\caption{Example entry in record table}
\end{center}
\end{table}


\subsubsection{Module}
A module is a table in the database that stores all modules installed by the user in the application. In Table 4.3, an illustration of the structure of a module is shown, with an entry of dummy data. In Nidra, the fields in the table contain the name of the module and the reference to the module and can be summarized as: 
\begin{itemize}
    \item \verb|ID|: Unique identification of a module, also a primary key for the entry.
    \item \verb|Name|: The name of the module-application.
    \item \verb|PackageName|: The package name of the module-application, such that it can be launched from Nidra. 
\end{itemize}

\begin{table}
\begin{center}
\scalebox{0.8}{
\begin{tabular}{ |c|c|c| } 
\hline
\textbf{id} & \textbf{name} & \textbf{packageName} \\
\hline
1 & OSA Predicter & com.package.osa\_predicter \\ 
\hline
\end{tabular}}
\caption{Example entry in record table}
\end{center}
\end{table}


\subsubsection{User}
Nidra considers the user of the application as the patient, hence storing biometrical data is part of the application to enrich the record data. In Table 4.4, an illustration of the structure of a user is shown, with an entry of dummy data. In Nidra, the fields in the table for a user contains biometrical data related to the user describe the data which are:
\begin{itemize}
    \item \verb|ID|: Unique identification of a module, also a primary key for the entry.
    \item \verb|Name|: The name of the module-application.
    \item \verb|Age|: Age of the user.
    \item \verb|Weight|: Weight of the user in kilograms.
    \item \verb|Height|: Height of the user in centimeters.
    \item \verb|CreatedAt|: Date of creation of the user in milliseconds (since January 1, 1970, 00:00:00 GMT).
\end{itemize}

\begin{table}
\begin{center}
\scalebox{0.8}{
\begin{tabular}{ |c|c|c|c|c|c|c| } 
\hline
\textbf{id} & \textbf{name} & \textbf{age} & \textbf{gender} & \textbf{height} & \textbf{weight} & \textbf{createdAt} \\
\hline
1 & Ola Nordmann & 50 & Male & 180 & 60 & -- \\ 
\hline
\end{tabular}}
\caption{Example entry in record table}
\end{center}
\end{table}

\subsection{Data Packets}
Data packets are parcels of data that Nidra receives from external applications (e.g., sensor wrappers) or send to other application (e.g., sharing). From the design choice In the Section above, the format of all the desired data should be according to the JSON format.  In this Section.

\subsubsection{Sharing}

In Section (ref), a proposal to the structure of exporting and importing data is discussed. Two of the components (\verb|Parse Formatted Content| and \verb|Format File|) uses JSON to either encode or decode the data. Listing 4.3 illustrate the content of the encoded data from our application to gain a broader understanding of how the data exchange in sharing operates. The attractive attributes from the encoding are the record (ref) and the samples.  A record is an object that contains meta-data with name, number of samples, recording time, creation date, and user information. Samples are an array of objects that contains data, timestamp, and identification to correlated record. 

\begin{figure}
    
\begin{lstlisting}[language=json, caption={My Caption}, captionpos=b]
{
    "record":{  
        "id": 1,
        "name": "Record 1",
        "rating": 2.5,
        "description": "",
        "nrSamples": 6107,
        "monitorTime": 5963088,
        "createdAt": "Apr 4, 2019 9:30:56 PM",
        "updatedAt": "Apr 4, 2019 9:30:56 PM",
        "user": {  
            "age": 50,
            "createdAt": "---",
            "gender": "Male",
            "height": 180,
            "name": "Ola Nordmann",
            "weight": 60
        }
    },
    "samples": [  
        {  
            "explicitTS":"Apr 4, 2019 5:51:26 PM",
            "implicitTS":"Apr 4, 2019 7:51:26 PM",
            "recordId":1,
            "sample":"Time=0ms, deltaT=100, data=1906,1891,1884,1881,1876,1718,1690"
        },
        ...
    ]
}
\end{lstlisting}
\end{figure}

\subsubsection{Sensor Data}
Sensor data is data acquisition through the Data Dispatching (section background). The data format discussed in (section background). 